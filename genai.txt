GENAI.TXT - AI ANALYSIS REFERENCE FOR DEVNAME RPG CLIENT
================================================================

PROJECT SCOPE:
Terminal-based RPG storytelling client leveraging Large Language Model capabilities through MCP (Model Control Protocol). Features innovative Story Momentum Engine, intelligent memory management, and completely rewritten ncurses interface with dynamic box coordinate system and modular architecture.

MODULE ARCHITECTURE:
main.py - Application coordination, prompt management, and lifecycle control
nci.py - Main ncurses interface controller with dynamic coordinate system
nci_terminal.py - Dynamic box coordinate system and terminal management
nci_input.py - Multi-line input system with cursor navigation
nci_scroll.py - Enhanced scrolling with page navigation
nci_display.py - Message formatting and display logic
nci_colors.py - Color theme management system
mcp.py - HTTP client for MCP/Ollama server communication  
emm.py - Enhanced Memory Manager with LLM-powered semantic condensation
sme.py - Story Momentum Engine for narrative pressure management

CRITICAL INTERCONNECTS:
main.py → nci.py: Creates CursesInterface with loaded prompt configuration
nci.py → nci_terminal.py: Uses TerminalManager for dynamic coordinate calculations
nci.py → nci_input.py: Manages MultiLineInput for enhanced text entry
nci.py → nci_scroll.py: Controls ScrollManager for history navigation
nci.py → nci_display.py: Uses DisplayMessage for formatted output
nci.py → nci_colors.py: Applies ColorManager for theme support
nci.py → mcp.py: Sends integrated system messages via MCPClient methods
nci.py → emm.py: Stores/retrieves messages via EnhancedMemoryManager
nci.py → sme.py: Updates narrative pressure via StoryMomentumEngine.process_user_input()
mcp.py ← sme.py: Receives story context via get_story_context()
mcp.py ← emm.py: Receives conversation history via get_conversation_for_mcp()

DATA FLOW:
1. Prompts loaded and optimized in main.py during startup
2. Dynamic coordinate system calculates optimal window layout in nci_terminal.py
3. User input captured through nci_input.py multi-line system with cursor navigation
4. Message stored in emm.py with automatic semantic analysis
5. Narrative pressure updated in sme.py based on input patterns
6. System messages built from loaded prompts + story context + conversation history
7. MCP request sent with complete message chain, response received
8. Response displayed through nci_display.py with immediate refresh pattern using dynamic coordinates

CONFIGURATION SYSTEM:
- Hardcoded configuration values in ApplicationConfig class
- memory.json: Persistent conversation memory (auto-created)
- Prompt files: critrules.prompt (required), companion.prompt, lowrules.prompt
- debug.log: Debug logging when --debug flag enabled

APPLICATION ENTRY POINT (main.py):
================================================================

ENHANCED PROMPT MANAGEMENT SYSTEM:
- PromptManager class with intelligent loading and condensation
- Token budget allocation (5,000 tokens for all prompts combined)
- Automatic prompt condensation using LLM when budget exceeded
- Critical validation ensuring critrules.prompt exists
- Graceful handling of missing optional prompt files

MAIN CLASS STRUCTURE:
- DevNameRPGClient: Primary application coordinator with prompt integration
- DebugLogger: Centralized logging system shared across modules
- ApplicationConfig: Hardcoded configuration management (no file creation)
- PromptManager: Handles prompt loading, optimization, and condensation

INITIALIZATION SEQUENCE:
1. Argument parsing and environment setup
2. Module verification and dependency checking
3. Hardcoded configuration loading
4. Debug logger initialization if enabled
5. Async prompt loading and optimization phase
6. CursesInterface creation with prompt injection
7. Signal handlers for graceful shutdown

PROMPT OPTIMIZATION ALGORITHM:
1. Load all available prompt files with graceful missing file handling
2. Calculate combined token usage with conservative estimation
3. Apply LLM-powered condensation if exceeding 5k token budget
4. Individual prompt condensation for files >1/3 of total budget
5. Verification of condensation effectiveness
6. Pass optimized prompts to interface configuration

CONFIGURATION DEFAULTS:
- MCP server: http://127.0.0.1:3456/chat
- MCP model: qwen2.5:14b-instruct-q4_k_m
- MCP timeout: 300 seconds
- Memory max tokens: 16,000
- Interface color theme: classic
- Story pressure decay: 0.05
- Antagonist threshold: 0.6

DEPENDENCY MANAGEMENT:
- Required: curses module (with platform-specific guidance)
- Required: httpx for MCP communication and prompt condensation
- Module verification system for all components
- Graceful degradation messaging for missing dependencies

DYNAMIC BOX COORDINATE SYSTEM (nci_terminal.py):
================================================================

COORDINATE SYSTEM ARCHITECTURE:
- BoxCoordinates dataclass: Defines outer boundaries and inner text fields
- LayoutGeometry dataclass: Complete terminal layout with all box definitions
- Dynamic layout calculation based on terminal dimensions
- Automatic proportional scaling (90% output, 10% input by default)

BOX COORDINATE CALCULATIONS:
1. Reserve 1 line for status at bottom
2. Reserve 2 lines for borders (between output/input, above status)
3. Split remaining lines with configurable ratio between output/input
4. Calculate inner coordinates for each box (excluding borders)
5. Generate complete layout geometry with metadata

TERMINAL MANAGEMENT:
- TerminalManager class: Handles resize detection and layout updates
- Periodic resize checking (every 0.5 seconds)
- Minimum size validation (80x24) with helpful error messages
- Complete layout recalculation on resize events
- Box border drawing with dynamic coordinate positioning

LAYOUT BENEFITS:
- Eliminates hardcoded coordinate assumptions
- Automatic adaptation to any terminal size
- Consistent proportional layouts across platforms
- Simplified resize handling with no manual calculations
- Robust coordinate system prevents curses NULL returns

NCURSES INTERFACE MODULE (nci.py) - DYNAMIC COORDINATES:
================================================================

DYNAMIC COORDINATE INTEGRATION:
- All window operations use BoxCoordinates from LayoutGeometry
- Automatic window recreation on resize with new coordinates
- Content rewrapping based on inner width calculations
- No manual coordinate calculations in display methods
- Simplified resize logic with consistent layout preservation

MODULAR ARCHITECTURE INTEGRATION:
- CursesInterface: Main controller coordinating all modules
- TerminalManager: Dynamic coordinate calculations and layout
- MultiLineInput: Advanced input handling from nci_input.py
- ScrollManager: Enhanced scrolling from nci_scroll.py
- DisplayMessage: Message formatting from nci_display.py
- ColorManager: Theme management from nci_colors.py

CORE INTERFACE FUNCTIONALITY:
- Immediate display pattern: All updates trigger instant refresh
- Message prefix improvements: AI→GM branding, clean system formatting
- True blank line separation between GM responses
- Enhanced navigation: page-based scrolling, home/end positioning
- Multi-line input with intelligent submission detection
- Command processing: /help, /quit, /clear, /stats, /theme

RESIZE HANDLING WITH DYNAMIC COORDINATES:
1. TerminalManager detects size change and calculates new layout
2. Component dimensions updated from new LayoutGeometry
3. Windows recreated using new BoxCoordinates
4. Content rewrapped for new inner dimensions
5. Complete display refresh with preserved scroll position

PROMPT INTEGRATION WORKFLOW:
- _build_system_messages(): Constructs integrated prompt chain
- Primary prompt (critrules) enhanced with story context injection
- Companion and narrative prompts added as separate system messages
- Custom MCP request building with complete message structure
- Fallback to standard send_message if custom approach fails

NO MCP CONNECTION TESTING:
- Eliminated startup connection testing entirely
- Errors only displayed during actual communication attempts
- Specific error types: ConnectionError, TimeoutError, general exceptions
- Graceful fallback patterns for MCP communication failures
- Clean startup experience without unnecessary error messages

MULTI-LINE INPUT SYSTEM (nci_input.py):
================================================================

ADVANCED INPUT HANDLING:
- MultiLineInput class with cursor navigation support
- Full arrow key navigation (left/right/up/down movement)
- Word wrapping at terminal boundaries with intelligent break points
- Intelligent submission detection based on content ending
- Line merging on backspace across line boundaries
- Character limit (4000) and line limit (10) for reasonable usage

CURSOR MANAGEMENT:
- Real-time cursor position tracking (line, column)
- Visual cursor mapping from logical to display coordinates
- Proper cursor positioning with prompt prefix consideration
- Navigation preservation during multi-line editing
- Automatic scroll adjustment to keep cursor visible

INPUT FEATURES:
- Smart Enter handling: new line vs submission based on context
- Automatic submission for commands (/) or punctuation endings
- Word wrapping with break point optimization
- Content validation with token estimation
- Multi-line display formatting within window constraints

ENHANCED SCROLLING SYSTEM (nci_scroll.py):
================================================================

SCROLLING CAPABILITIES:
- ScrollManager class with comprehensive navigation support
- Line-based scrolling with arrow keys when not in input mode
- Page-based navigation with PgUp/PgDn keys
- Home/End keys for instant top/bottom navigation
- Scroll indicators in status bar showing position and state

SCROLLBACK MANAGEMENT:
- SCROLLBACK indicator when viewing history (not at bottom)
- Auto-return to bottom on new message submission
- Scroll position preservation during terminal resize
- Maximum scroll calculation based on content and window height
- Intelligent scroll offset management

MESSAGE DISPLAY SYSTEM (nci_display.py):
================================================================

DISPLAY MESSAGE FORMATTING:
- DisplayMessage class with type-specific formatting
- Updated prefix system: "You:", "GM:", " :", "Error:"
- Message wrapping with proper line continuation indentation
- Timestamp integration with configurable format
- Content-aware wrapping with break optimization

INPUT VALIDATION:
- InputValidator class with multi-line support awareness
- Token estimation for content length validation
- Line count validation (maximum 20 lines)
- Specific error messages for different validation failures
- Integration with input system for real-time feedback

COLOR THEME SYSTEM (nci_colors.py):
================================================================

THEME MANAGEMENT:
- ColorManager class with dynamic theme switching
- Three built-in themes: classic, dark, bright
- Runtime theme changing with immediate refresh
- Graceful fallback for terminals without color support
- Color pair management with proper initialization

COLOR ASSIGNMENTS:
- Classic theme: Cyan users, green GM, yellow system, red errors, blue borders
- Dark theme: White users, cyan GM, magenta system, red errors, white borders
- Bright theme: Blue users, green GM, yellow system, red errors, magenta borders

MCP COMMUNICATION MODULE (mcp.py):
================================================================

STREAMLINED ARCHITECTURE:
- MCPClient class with essential HTTP communication
- Single retry mechanism (MCP_MAX_RETRIES = 2)
- Clean context integration from EMM and SME modules
- Eliminated performance monitoring for simplicity

CORE FUNCTIONALITY:
- MCPClient.send_message(): Primary interface with story context integration
- MCPClient._execute_request(): Direct request execution for custom message chains
- MCPClient.test_connection(): Async connection verification
- MCPClient.get_server_info(): Basic diagnostics
- MCPClient.update_system_prompt(): Dynamic prompt modification

ERROR HANDLING:
- Single exception type for all MCP failures
- Debug-only verbose logging
- Graceful fallback when httpx unavailable
- Brief retry delays (1 second) without complex backoff

CONTEXT INTEGRATION DESIGN:
- Story context from SME injected as system message
- Conversation history from EMM limited to last 10 messages
- System prompt + story context + history + user input = complete chain
- Minimal response validation for essential structure checking

ENHANCED MEMORY MANAGER MODULE (emm.py):
================================================================

SEMANTIC ANALYSIS SYSTEM:
- LLM-powered message categorization with 6 semantic categories
- Context-aware analysis using 11-message window (5 before + target + 5 after)
- 3-tier retry system: Full Analysis → Simple Analysis → Binary Decision
- Pure LLM-driven semantic decisions with programmatic fallbacks

SEMANTIC CATEGORIES & PRESERVATION RATIOS:
- story_critical: 0.9 (90% preservation) - Major plot developments, character deaths, world-changing events
- character_focused: 0.8 (80% preservation) - Relationship changes, character development, personality reveals
- relationship_dynamics: 0.8 (80% preservation) - Evolving relationships between characters
- emotional_significance: 0.75 (75% preservation) - Dramatic moments, trust/betrayal, conflict resolution
- world_building: 0.7 (70% preservation) - New locations, lore, cultural info, political changes
- standard: 0.4 (40% preservation) - General interactions, travel, routine activities

PROGRESSIVE CONDENSATION SYSTEM:
- Multi-pass condensation with increasing aggressiveness (up to 3 passes)
- Aggressiveness reduces preservation ratios by 0.1 per pass
- Minimum preservation ratio of 0.2 to prevent critical information loss
- Recent messages (last 5) always protected from condensation

STORY MOMENTUM ENGINE MODULE (sme.py):
================================================================

NARRATIVE PRESSURE SYSTEM:
- Dynamic pressure tracking on 0.0-1.0 scale with pattern-based calculation
- Real-time story arc progression: Setup → Rising Action → Climax → Resolution
- Context-adaptive antagonist generation based on user input patterns
- Rate limiting (2-second cooldown) to prevent spam-induced pressure spikes

PRESSURE CALCULATION ALGORITHM:
- Pattern-based analysis using 6 momentum categories
- Weighted keyword matching with dynamic pressure deltas per category
- Length/complexity factors and punctuation intensity analysis
- Natural pressure decay over time (0.05 per minute) to prevent inflation
- Maximum single increase cap of 0.3 to prevent extreme spikes

MOMENTUM PATTERN CATEGORIES:
- conflict: Keywords trigger +0.15 pressure (fight, attack, defend, battle, combat, strike)
- tension: Keywords trigger +0.12 pressure (danger, threat, fear, worry, concern, risk)
- mystery: Keywords trigger +0.08 pressure (strange, unusual, mysterious, hidden, secret, whisper)
- exploration: Keywords trigger +0.05 pressure (examine, search, look, investigate, explore, discover)
- social: Keywords trigger +0.03 pressure (talk, speak, negotiate, persuade, convince, ask)
- resolution: Keywords trigger -0.10 pressure (resolve, solution, answer, complete, finish, end)

ANTAGONIST MANAGEMENT:
- Context-adaptive antagonist generation at 0.6 pressure threshold
- Dynamic antagonist types based on recent user input analysis:
  * magical_opposition: Corrupted Mage (magic/spell keywords detected)
  * environmental_threat: Ancient Guardian (exploration/dungeon keywords)
  * social_conflict: Corrupt Official (town/people keywords)
  * adaptive_threat: Shadow Entity (default context-adaptive)
- Threat level scaling with current pressure level
- Automatic deactivation during Resolution arc

PROMPT SYSTEM INTEGRATION:
================================================================

PROMPT FILE ARCHITECTURE:
- critrules.prompt: Core GM rules and character control boundaries (REQUIRED)
- companion.prompt: Active companion character definition (OPTIONAL)
- lowrules.prompt: World generation and environmental storytelling rules (OPTIONAL)

COMPANION PROMPT TEMPLATES:
- tsundere_companion.prompt: Seraphina knight companion template
- dandere_companion.prompt: Elena healer companion template
- kuudere_companion.prompt: Lysander mage companion template
- himedere_companion.prompt: Victoria noble companion template

INTELLIGENT PROMPT LOADING:
- Graceful handling of missing files with user warnings
- Automatic token estimation and budget management
- LLM-powered condensation when exceeding 5k token allocation
- Preservation of essential functionality during condensation
- Status display showing active prompt components in interface

PROMPT INTEGRATION WORKFLOW:
1. Load available prompt files during startup
2. Apply condensation if budget exceeded
3. Pass optimized prompts to interface configuration
4. Build dynamic system messages with story context injection
5. Combine prompts + context + history for complete message chain
6. Real-time status display showing active prompt count

TOKEN BUDGET ALLOCATION:
- Total Context Window: 32,000 tokens
- System Prompts: 5,000 tokens (auto-optimized)
- Memory Storage: 16,000 tokens (semantic categorization)
- Input Buffer: Remaining capacity with validation

INTERFACE REWRITE ACHIEVEMENTS:
================================================================

DYNAMIC COORDINATE SYSTEM:
- Eliminated all hardcoded coordinate assumptions
- Automatic adaptation to any terminal size with proportional scaling
- Consistent layout behavior across different platforms
- Simplified resize handling with no manual coordinate calculations
- Robust window positioning prevents curses NULL returns

MODULAR ARCHITECTURE:
- Clean separation of concerns across 6 interface modules
- Each module handles specific functionality independently
- Clear interfaces between modules with minimal coupling
- Easier maintenance and testing of individual components
- Simplified debugging with focused module responsibilities

ENHANCED USER EXPERIENCE:
- Multi-line input with intelligent submission detection
- Enhanced scrolling with page navigation and position indicators
- True blank line separation between GM responses for readability
- Improved message prefixes (AI→GM) for better immersion
- Real-time status display with comprehensive system information

ELIMINATED COMPLEXITY:
- Removed MCP connection testing at startup for cleaner initialization
- Simplified command system with focused functionality
- Streamlined resize handling through dynamic coordinate system
- Reduced coordinate-related bugs through systematic approach
- Cleaner API surface without backwards compatibility concerns

TECHNICAL EXCELLENCE:
================================================================

PERFORMANCE OPTIMIZATIONS:
- Immediate display pattern with minimal refresh overhead
- Efficient content rewrapping only when necessary
- Optimized scroll calculations with cached dimensions
- Real-time input validation without blocking interface
- Lazy evaluation of layout calculations

ROBUSTNESS FEATURES:
- Graceful degradation with missing components or terminals
- Comprehensive error handling with contextual messages
- Safe fallback patterns for all critical operations
- Protection against curses exceptions and terminal limitations
- Automatic recovery from resize-related disruptions

DEBUGGING CAPABILITIES:
- Comprehensive debug logging across all modules
- Real-time status monitoring with detailed metrics
- Interface state inspection utilities for development
- Terminal dimension tracking and layout validation
- Module interconnect verification and troubleshooting

ARCHITECTURAL INNOVATIONS:
================================================================

DYNAMIC BOX COORDINATE SYSTEM:
- Mathematical layout calculation eliminates coordinate assumptions
- Proportional scaling maintains visual consistency across terminal sizes
- Box coordinate abstraction simplifies window management
- Layout geometry provides complete spatial context
- Automatic border positioning and content area calculation

MODULAR INTERFACE ARCHITECTURE:
- Clean separation enables independent module development
- Interface modules can be modified without affecting core logic
- Simplified testing through focused module responsibilities
- Consistent API contracts between interface components
- Easier maintenance and feature extension

INTEGRATED PROMPT SYSTEM:
- Dynamic prompt loading with intelligent optimization
- LLM-powered condensation preserves functionality within token limits
- Story context injection enhances narrative coherence
- Multi-prompt integration with hierarchical message construction
- Real-time prompt status monitoring and validation

STORY MOMENTUM ENGINE INTEGRATION:
- Mathematical pressure modeling prevents common AI storytelling pitfalls
- Context-adaptive antagonist generation based on player behavior
- Natural pressure decay prevents artificial tension inflation
- Seamless integration with interface for enhanced user experience

SEMANTIC MEMORY MANAGEMENT:
- LLM-powered categorization with intelligent preservation strategies
- Progressive condensation maintains story continuity
- Thread-safe operations with async LLM calls
- Content-type specific preservation ratios optimize memory usage

MODULAR PRESERVATION RULES:
================================================================

1. Dynamic coordinate system must be preserved across all interface components
2. ModuLinear architecture boundaries must be maintained for clean separation
3. Prompt integration workflow must preserve token budget management
4. Story momentum engine integration must maintain pressure calculation accuracy
5. Memory management semantic categorization must preserve content quality
6. MCP communication must maintain context integration from EMM and SME
7. Interface immediate display pattern must preserve real-time user feedback
8. Multi-line input system must preserve cursor navigation functionality
9. Terminal resize handling must preserve content and scroll position
10. Color theme system must preserve accessibility and visual hierarchy

ERROR HANDLING HIERARCHY:
- main.py: Application-level errors, prompt loading failures, graceful shutdown
- nci.py: Interface coordination errors, module integration failures
- nci_terminal.py: Terminal size validation, coordinate calculation errors
- nci_input.py: Input processing errors, cursor positioning failures
- nci_scroll.py: Scroll position validation, history navigation errors
- nci_display.py: Message formatting errors, display validation failures
- nci_colors.py: Color initialization errors, theme switching failures
- mcp.py: Network errors and communication failures
- emm.py: Memory management errors, semantic analysis failures
- sme.py: Narrative analysis and pressure calculation errors

DEBUGGING INFRASTRUCTURE:
- Centralized DebugLogger class shared across all modules
- Module-specific debug categories for focused troubleshooting
- Real-time interface state inspection and validation
- Dynamic coordinate system layout debugging
- Multi-line input state analysis and cursor tracking
- Scroll position monitoring and history navigation testing
- Memory management semantic analysis tracking
- Story pressure calculation and antagonist lifecycle monitoring
- Prompt loading and condensation process logging
- MCP communication with simplified debug output

DEPENDENCY REQUIREMENTS:
- Python 3.8+ with curses support
- httpx library for HTTP communication (REQUIRED for full functionality)
- asyncio for non-blocking LLM calls in memory management
- JSON for configuration and history storage
- Threading for thread-safe memory operations
- textwrap for multi-line input word wrapping

AI MODIFICATION GUIDELINES:
================================================================

1. PRESERVE dynamic box coordinate system when modifying interface components
2. MAINTAIN modular architecture boundaries between interface modules
3. UPDATE coordinate calculations only through TerminalManager and LayoutGeometry
4. VERIFY that interface changes work with all three color themes
5. TEST multi-line input functionality after cursor-related modifications
6. ENSURE scroll position preservation during resize operations
7. VALIDATE that prompt integration maintains token budget constraints
8. MAINTAIN immediate display pattern for all message additions
9. PRESERVE story momentum engine integration for narrative coherence
10. TEST semantic memory management after EMM modifications
11. VERIFY MCP context integration after communication changes
12. MAINTAIN graceful degradation patterns for missing components
13. UPDATE genai.txt documentation when making architectural changes
14. PRESERVE the modular separation that enables independent development
15. ENSURE that coordinate system changes maintain visual consistency

INTERFACE MODULE ARCHITECTURE BENEFITS:
================================================================

DEVELOPMENT EFFICIENCY:
- Independent module development without affecting other components
- Focused testing scope for each interface functionality
- Simplified debugging through clear module boundaries
- Easier feature addition through modular extension points
- Reduced complexity in individual module maintenance

SYSTEM RELIABILITY:
- Failure isolation prevents cascading interface problems
- Graceful degradation when individual modules encounter errors
- Clear error attribution through module-specific logging
- Simplified recovery procedures through module restart capabilities
- Consistent behavior patterns across all interface components

USER EXPERIENCE CONSISTENCY:
- Unified behavior patterns across all interface interactions
- Consistent visual feedback through coordinated color theming
- Reliable input handling through dedicated input module
- Smooth scrolling experience through specialized scroll management
- Professional appearance through dynamic coordinate system precision