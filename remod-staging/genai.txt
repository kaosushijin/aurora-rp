# GENAI.TXT - AI ANALYSIS REFERENCE FOR DEVNAME RPG CLIENT (REMODULARIZED)
================================================================

## PROJECT SCOPE
Terminal-based RPG storytelling client leveraging Large Language Model capabilities through MCP (Model Context Protocol). Features clean hub-and-spoke architecture with centralized orchestration, consolidated UI library, and exclusive LLM communication patterns for optimal maintainability and performance.

## PROGRAM FLOW ANALYSIS (Remodularized Hub-and-Spoke Architecture)

### Application Entry Point (main.py)
1. **Environment Setup**: Module verification for remodularized files, dependency validation, terminal capability checks
2. **Prompt Management**: Load and validate prompt files with LLM-powered condensation within 5,000 token budget
3. **Orchestrator Initialization**: Create central Orchestrator hub with loaded prompts and configuration
4. **Hub Coordination**: Transfer control to Orchestrator for centralized module management and main program logic

### Core Execution Flow
```
main() → initialize_application() → DevNameRPGClient.run() → Orchestrator.run_main_loop()
```

## REMODULARIZED MODULE ARCHITECTURE

### Hub Module

**orch.py** - Central Orchestrator Hub
- `Orchestrator`: Central coordination class managing all service modules
- **EXCLUSIVE** MCP client access - only module that communicates with mcp.py
- Main program logic coordination and state management
- **Key Features**:
  - Hub-and-spoke communication patterns
  - Centralized LLM request coordination
  - Background analysis threading management
  - Service module lifecycle management

### Spoke Modules (Service Providers)

**ncui.py** - Pure UI Controller (replaces nci.py)
- `NCursesUIController`: Clean UI management without business logic
- Interfaces with orchestrator through callback patterns
- **Key Features**:
  - Pure display and input handling
  - Dynamic window management using uilib components
  - Orchestrator communication for business logic delegation

**uilib.py** - Consolidated UI Library (consolidates nci_*.py)
- `ColorManager`, `ColorTheme`: Unified color management
- `TerminalManager`, `LayoutGeometry`: Dynamic coordinate system
- `MultiLineInput`, `InputValidator`: Enhanced input handling
- `ScrollManager`: Content navigation
- `DisplayMessage`: Type-specific formatting
- **Benefits**:
  - Single cohesive UI library eliminates fragmentation
  - All UI utilities in one importable module
  - Consistent interfaces across components

**sem.py** - Semantic Analysis Engine (NEW - centralized)
- `SemanticAnalysisEngine`: Centralized semantic processing logic
- LLM request preparation without direct communication
- **Key Features**:
  - 3-attempt semantic analysis strategy
  - Message categorization with importance scoring
  - Robust JSON parsing with fallback strategies
  - Coordinates through orchestrator for LLM requests

**emm.py** - Enhanced Memory Manager (SIMPLIFIED)
- `EnhancedMemoryManager`: Storage and state management only
- **Removed**: Semantic analysis logic (moved to sem.py)
- **Removed**: Direct MCP communication (coordinated through orch.py)
- **Key Features**:
  - Message persistence and threading
  - State management for momentum data
  - Background auto-save operations
  - Clean orchestrator interfaces

**sme.py** - Story Momentum Engine (SIMPLIFIED)  
- `StoryMomentumEngine`: Basic pattern detection and state tracking
- **Removed**: LLM analysis logic (moved to sem.py)
- **Removed**: Direct MCP communication (coordinated through orch.py)
- **Key Features**:
  - Pressure level calculation
  - Story arc progression tracking
  - Basic momentum pattern detection
  - Clean orchestrator interfaces

**mcp.py** - MCP Communication Module (EXCLUSIVE ACCESS)
- `MCPClient`: HTTP-based Model Context Protocol communication
- **CRITICAL**: Only accessed by orch.py orchestrator
- **Key Features**:
  - 5-strategy JSON parsing for response reliability
  - Context integration with story state
  - Robust retry mechanism with error handling
  - Exclusive hub access pattern

## CRITICAL ARCHITECTURAL PRINCIPLES

### Hub-and-Spoke Communication
- **ONLY** `orch.py` communicates with `mcp.py` for LLM requests
- **NO** spoke-to-spoke communication allowed
- All inter-module coordination flows through central orchestrator
- Clean separation of concerns maintained

### Module Responsibility Matrix
```
Module      | UI | Business Logic | Storage | LLM | Semantics
------------|----|-----------------|---------|----- |-----------
orch.py     | No | YES (central)  | No      | YES | Coordinate
ncui.py     | YES| No              | No      | No  | No
uilib.py    | YES| No              | No      | No  | No
sem.py      | No | No              | No      | No  | YES
emm.py      | No | No              | YES     | No  | No
sme.py      | No | Basic patterns  | Basic   | No  | No
mcp.py      | No | No              | No      | YES | No
```

## COMPLETE DATA FLOW PIPELINE (REMODULARIZED)

1. **Startup**: Orchestrator initializes all service modules in dependency order
2. **UI Initialization**: Pure UI controller created using consolidated uilib components
3. **Input Processing**: User input flows from ncui.py → orch.py for coordination
4. **Context Gathering**: Orchestrator collects context from emm.py (storage) and sme.py (state)
5. **Semantic Analysis**: Orchestrator coordinates sem.py for message categorization
6. **LLM Communication**: EXCLUSIVE orchestrator access to mcp.py for requests
7. **Response Handling**: Orchestrator processes LLM responses and updates modules
8. **Background Analysis**: 15-message cycle triggers coordinated semantic analysis
9. **State Persistence**: Background auto-save through emm.py threading
10. **Display Updates**: Orchestrator sends formatted content to ncui.py for display

## ORCHESTRATOR COORDINATION PATTERNS

### Service Module Initialization
```python
# Dependency order initialization
1. TerminalManager (no dependencies)
2. EnhancedMemoryManager (no dependencies) 
3. StoryMomentumEngine (no dependencies)
4. SemanticAnalysisEngine (no dependencies)
5. MCPClient (no dependencies)
6. NCursesUIController (requires uilib)
```

### LLM Request Coordination
```python
# EXCLUSIVE orchestrator pattern
def send_llm_request(self, request_data: Dict[str, Any]) -> Optional[str]:
    # 1. Validate request structure
    # 2. Gather context from service modules
    # 3. Send via MCP client (exclusive access)
    # 4. Process response
    # 5. Update service modules with results
```

### Periodic Analysis Coordination
```python
# 15-message cycle coordination
def trigger_periodic_analysis(self) -> None:
    # 1. Gather messages from emm.py
    # 2. Request semantic analysis from sem.py
    # 3. Send analysis request via mcp.py
    # 4. Process results and update modules
```

## ARCHITECTURAL BENEFITS ACHIEVED

### **Maintainability**
- Single responsibility principle enforced across all modules
- Clear boundaries prevent coupling issues
- Centralized business logic in orchestrator
- UI consolidation eliminates fragmentation

### **Testability**
- Individual modules can be unit tested in isolation
- Mock orchestrator enables service module testing
- Clear interfaces facilitate integration testing
- Predictable data flow patterns

### **Scalability**
- New features added through orchestrator coordination
- Service modules can be enhanced independently
- Clean extension points for additional functionality
- No impact on UI when adding business logic

### **Performance**
- No additional overhead from hub-and-spoke pattern
- Background threading preserved and coordinated
- Efficient LLM communication through single channel
- Optimized memory management maintained

## MODULE INTERCONNECT SUMMARY

### Data Flow Dependencies
- `main.py → orch.py`: Configuration and loaded prompts
- `orch.py → ncui.py`: Display coordination and input collection
- `orch.py → emm.py`: Storage operations and state queries
- `orch.py → sme.py`: Basic momentum state and pattern detection
- `orch.py → sem.py`: Semantic analysis coordination
- `orch.py → mcp.py`: EXCLUSIVE LLM communication
- `ncui.py → uilib.py`: UI component utilization

### Interface Standards
```python
# Orchestrator callback pattern
def orchestrator_callback(self, request: Dict[str, Any]) -> Optional[Dict[str, Any]]

# Service module interface
def initialize(self, orchestrator_callback: Callable) -> bool
def shutdown(self) -> None

# Data format standards maintained across all modules
message_format = {"content": str, "type": str, "timestamp": str}
context_format = {"conversation": List, "story_state": Dict, "prompts": Dict}
```

## CURRENT IMPLEMENTATION STATUS

### **Completed Remodularization Elements**
- ✅ Hub-and-spoke architecture with central orchestrator
- ✅ UI consolidation into single uilib.py library
- ✅ Semantic analysis centralization in sem.py
- ✅ Simplified spoke modules with clean interfaces
- ✅ Exclusive MCP access through orchestrator
- ✅ All original functionality preserved

### **Architectural Compliance**
- ✅ No spoke-to-spoke communication
- ✅ Single responsibility per module
- ✅ Clean separation of concerns
- ✅ Standardized data formats
- ✅ Consistent error handling

### **Performance Characteristics**
- Maintained 15-message analysis cycles
- Preserved background auto-save threading
- Sustained UI responsiveness
- Identical feature set with improved structure

## USAGE INSTRUCTIONS

### Basic Operation
- Run `python main.py` from remodularized directory
- All modules must be present in same directory
- Ensure critrules.prompt exists in parent directory
- Use `python main.py --debug` for comprehensive orchestrator logging

### Commands
- **Multi-line Input**: Type naturally, double-enter to submit
- **Navigation**: PgUp/PgDn for scrolling, Home/End for quick navigation  
- **Commands**: `/help`, `/stats`, `/analyze`, `/theme <n>`, `/clearmemory`

### Debug Features
- Orchestrator coordination logging
- Service module interaction tracking
- Hub-and-spoke communication monitoring
- Semantic analysis decision logging
- Background thread coordination visibility

---
Last Updated: Remodularized Hub-and-Spoke Architecture Analysis
Project State: Complete architectural transformation with preserved functionality and improved maintainability